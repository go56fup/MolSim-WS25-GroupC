#pragma once

#include <source_location>
#include <string_view>

#include <spdlog/spdlog.h>

#include "FixedString.h"

/**
* @brief Class to log special member function calls of particles.
*
* @tparam DerivedName A compile-time fixed string representing the name of the derived type.
*/
template <p3094::fixed_string DerivedName>
class flag_special_member_funcs {
public:
	/**
	* @brief Constructor logs object construction.
	* @param loc Source location of the constructor call.
	*/
	// NOLINTNEXTLINE(*explicit*)
	constexpr flag_special_member_funcs(const std::source_location& loc = std::source_location::current()) {
		log_special_mem("construction", loc);
	}
	/**
	* @brief Copy constructor logs copy events.
	* @param  Object being copied.
	* @param loc Source location of the copy.
	*/
	constexpr flag_special_member_funcs(
		const flag_special_member_funcs&, const std::source_location& loc = std::source_location::current()
	) noexcept {
		log_special_mem("copy", loc);
	}
	/**
	* @brief Move constructor logs move events.
	* @param Object being moved.
	* @param loc Source location of the move.
	*/
	constexpr flag_special_member_funcs(
		flag_special_member_funcs&&, const std::source_location& loc = std::source_location::current()
	) noexcept {
		log_special_mem("move", loc);
	}

	/**
	* @brief Copy assignment operator logs copy assignment.
	* @param Object being copy-assigned.
	* @return Reference to *this.
	*/
	// NOLINTNEXTLINE(cert-oop54-cpp)
	constexpr flag_special_member_funcs& operator=(const flag_special_member_funcs&) noexcept {
		runtime_log(DerivedName + " copy assigned!\n");
		return *this;
	}

	/**
	* @brief Move assignment operator logs move assignment.
	* @param Object being move-assigned.
	* @return Reference to *this.
	*/
	constexpr flag_special_member_funcs& operator=(flag_special_member_funcs&&) noexcept {
		runtime_log(DerivedName + " move assigned!\n");
		return *this;
	}
	/**
	* @brief Destructor logs object destruction.
	*/
	constexpr ~flag_special_member_funcs() noexcept {
		runtime_log(DerivedName + " destructed!\n");
	}

	/**
	 * @brief Equality comparison of particles through special member function.
	 * @param other The other particle to compare with.
	 * @return true if both particles are considered equal.
	 */
	constexpr bool operator==(const flag_special_member_funcs& other) const = default;

	/**
	 * @brief Logs the creation of a particle through a special member function.
	 *
	 * @param by A description of how the particle was created (e.g., "copy", "move").
	 * @param location Automatically captured source location of the call.
	 */
	static constexpr void log_special_mem(std::string_view by, const std::source_location& location) {
		runtime_log(
			"{}:{}:{}: " + DerivedName + " generated by {}!\n", location.file_name(), location.line(),
			location.column(), by
		);
	}

	// TODO(anyone): document me
	/**
	 * @brief Logs the reason for a particle creation through a special member function.
	 *
	 * @param reason A description of why the particle was created
	 * @param location Automatically captured source location of the call.
	 */
	static constexpr void annotate_construction(std::string_view reason, const std::source_location& location) {
		runtime_log(
			"{}:{}:{}: " + DerivedName + "'s last logged construction was {}\n", location.file_name(), location.line(),
			location.column(), reason
		);
	}

	/**
	 * @brief Prints a log message only at runtime.
	 *
	 * This method ensures that logging statements are skipped
	 * during compile-time evaluation (constexpr contexts).
	 *
	 * @tparam Args Variadic pack of argument types passed to the formatting facility.
	 * @param fmt_string String describing the format of the output.
	 * @param args Arguments to format according to `fmt_string`.
	 */
	template <typename... Args>
	// std::make_format_args accepts lvalue references only, so strip references via universal passing:
	// runtime_log(int&&) -> Args&& = int&& -> deduced as int -> make_format_args(int) -> int& binds to int.
	// runtime_log(int&) -> Args&& = int& && -> deduced as int& -> make_format_args(int&) -> int& binds to
	// int&: dropping the rvalue is fine as the object gets destructed at the semicolon, after the formatting
	// is over.
	// NOLINTNEXTLINE(*missing-std-forward)
	static constexpr void runtime_log(std::string_view fmt_string, Args&&... args) {
		// Even though it should be, it is not possible to use std::format_string<Args...> here.
		// Taking the format string via std::format_string invokes a consteval constructor,
		// (which in itself is fine since the string is known at compile-time).
		// We are in a templated constexpr context, which forces immediate-promotion, promoting the
		// special member function calling the logger to consteval.
		// In the corresponding implicitly defined or explicitly defaulted special member function
		// of a deriving class, a call to this baseclass' special member function is generated by the compiler.
		// This TRANSITIVELY forces immediate-promotion, making e.g. constexpr operator= for vec consteval,
		// and breaking runtime code.

		if not consteval {
			spdlog::trace(fmt::vformat(fmt_string, fmt::make_format_args(args...)));
		}
	}
};

#ifndef NDEBUG
#define LOG_SPECIAL_MEMBER_FUNCS_DEBUG(...) : flag_special_member_funcs < __VA_ARGS__ >
#else
#define LOG_SPECIAL_MEMBER_FUNCS_DEBUG(...)
#endif

// Conditionally inheriting from flag_special_member_funcs makes types non-trivially constructible,
// so a move becomes appropriate.
#ifndef NDEBUG
#define MOVE_IF_DEBUG(a) std::move(a)
#else
#define MOVE_IF_DEBUG(a) a
#endif
