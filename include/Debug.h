#pragma once

#include <source_location>
#include <string_view>

#include <spdlog/spdlog.h>

#include "FixedString.h"

template <p3094::fixed_string DerivedName>
class flag_special_member_funcs {
public:
	// NOLINTNEXTLINE(*explicit*)
	constexpr flag_special_member_funcs(const std::source_location& loc = std::source_location::current()) {
		log_special_mem("construction", loc);
	}

	constexpr flag_special_member_funcs(
		const flag_special_member_funcs&, const std::source_location& loc = std::source_location::current()
	) noexcept {
		log_special_mem("copy", loc);
	}

	constexpr flag_special_member_funcs(
		flag_special_member_funcs&&, const std::source_location& loc = std::source_location::current()
	) noexcept {
		log_special_mem("move", loc);
	}

	// NOLINTNEXTLINE(cert-oop54-cpp)
	constexpr flag_special_member_funcs& operator=(const flag_special_member_funcs&) noexcept {
		runtime_log(DerivedName + " copy assigned!\n");
		return *this;
	}

	constexpr flag_special_member_funcs& operator=(flag_special_member_funcs&&) noexcept {
		runtime_log(DerivedName + " move assigned!\n");
		return *this;
	}

	constexpr ~flag_special_member_funcs() noexcept {
		runtime_log(DerivedName + " destructed!\n");
	}

	constexpr bool operator==(const flag_special_member_funcs& other) const = default;

	/**
	 * @brief Logs the creation of a particle through a special member function.
	 *
	 * @param by A description of how the particle was created (e.g., "copy", "move").
	 * @param location Automatically captured source location of the call.
	 */
	static constexpr void log_special_mem(std::string_view by, const std::source_location& location) {
		runtime_log(
			"{}:{}:{}: " + DerivedName + " generated by {}!\n", location.file_name(), location.line(),
			location.column(), by
		);
	}

	// TODO(anyone): document me
	static constexpr void annotate_construction(std::string_view reason, const std::source_location& location) {
		runtime_log(
			"{}:{}:{}: " + DerivedName + "'s last logged construction was {}\n", location.file_name(), location.line(),
			location.column(), reason
		);
	}

	/**
	 * @brief Prints a log message only at runtime.
	 *
	 * This method ensures that logging statements are skipped
	 * during compile-time evaluation (constexpr contexts).
	 *
	 * @tparam Args Variadic pack of argument types passed to the formatting facility.
	 * @param fmt_string String describing the format of the output.
	 * @param args Arguments to format according to `fmt_string`.
	 */
	template <typename... Args>
	// std::make_format_args accepts lvalue references only, so strip references via universal passing:
	// runtime_log(int&&) -> Args&& = int&& -> deduced as int -> make_format_args(int) -> int& binds to int.
	// runtime_log(int&) -> Args&& = int& && -> deduced as int& -> make_format_args(int&) -> int& binds to
	// int&: dropping the rvalue is fine as the object gets destructed at the semicolon, after the formatting
	// is over.
	// NOLINTNEXTLINE(*missing-std-forward)
	static constexpr void runtime_log([[maybe_unused]] std::string_view fmt_string, [[maybe_unused]] Args&&... args) {
		SPDLOG_TRACE(fmt::vformat(fmt_string, fmt::make_format_args(args...)));
	}
};

#ifndef NDEBUG
#define LOG_SPECIAL_MEMBER_FUNCS_DEBUG(...) : flag_special_member_funcs < __VA_ARGS__ >
#else
#define LOG_SPECIAL_MEMBER_FUNCS_DEBUG(...)
#endif

// Conditionally inheriting from flag_special_member_funcs makes types non-trivially constructible,
// so a move becomes appropriate.
#ifndef NDEBUG
#define MOVE_IF_DEBUG(a) std::move(a)
#else
#define MOVE_IF_DEBUG(a) a
#endif
