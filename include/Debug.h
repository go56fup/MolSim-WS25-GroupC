#pragma once

#include <source_location>
#include <string_view>

#include <spdlog/spdlog.h>

#include "FixedString.h"

template <p3094::fixed_string DerivedName>
class flag_special_member_funcs {
public:
	// NOLINTNEXTLINE(*explicit*)
	constexpr flag_special_member_funcs(const std::source_location& loc = std::source_location::current()) {
		log_special_mem("construction", loc);
	}

	constexpr flag_special_member_funcs(
		const flag_special_member_funcs&, const std::source_location& loc = std::source_location::current()
	) noexcept {
		log_special_mem("copy", loc);
	}

	constexpr flag_special_member_funcs(
		flag_special_member_funcs&&, const std::source_location& loc = std::source_location::current()
	) noexcept {
		log_special_mem("move", loc);
	}

	// NOLINTNEXTLINE(cert-oop54-cpp)
	constexpr flag_special_member_funcs& operator=(const flag_special_member_funcs&) noexcept {
		runtime_log(DerivedName + " copy assigned!\n");
		return *this;
	}

	constexpr flag_special_member_funcs& operator=(flag_special_member_funcs&&) noexcept {
		runtime_log(DerivedName + " move assigned!\n");
		return *this;
	}

	constexpr ~flag_special_member_funcs() noexcept {
		runtime_log(DerivedName + " destructed!\n");
	}

	constexpr bool operator==(const flag_special_member_funcs& other) const = default;

	/**
	 * @brief Logs the creation of a particle through a special member function.
	 *
	 * @param by A description of how the particle was created (e.g., "copy", "move").
	 * @param location Automatically captured source location of the call.
	 */
	static constexpr void log_special_mem(std::string_view by, const std::source_location& location) {
		runtime_log(
			"{}:{}:{}: " + DerivedName + " generated by {}!\n", location.file_name(), location.line(),
			location.column(), by
		);
	}

	/**
	 * @brief Prints a log message only at runtime.
	 *
	 * This method ensures that logging statements are skipped
	 * during compile-time evaluation (constexpr contexts).
	 *
	 * @tparam Args Variadic pack of argument types passed to the formatting facility.
	 * @param fmt_string String describing the format of the output.
	 * @param args Arguments to format according to `fmt_string`.
	 */
	template <typename... Args>
	// std::make_format_args accepts lvalue references only, so strip references via universal passing:
	// runtime_log(int&&) -> Args&& = int&& -> deduced as int -> make_format_args(int) -> int& binds to int.
	// runtime_log(int&) -> Args&& = int& && -> deduced as int& -> make_format_args(int&) -> int& binds to
	// int&: dropping the rvalue is fine as the object gets destructed at the semicolon, after the formatting
	// is over.
	// NOLINTNEXTLINE(*missing-std-forward)
	static constexpr void runtime_log(std::string_view fmt_string, Args&&... args) {
		// Even though it should be, it is not possible to use std::format_string<Args...> here.
		// Taking the format string via std::format_string invokes a consteval constructor,
		// (which in itself is fine since the string is known at compile-time).
		// We are in a templated constexpr context, which forces immediate-promotion, promoting the
		// special member function calling the logger to consteval.
		// In the corresponding implicitly defined or explicitly defaulted special member function
		// of a deriving class, a call to this baseclass' special member function is generated by the compiler.
		// This TRANSITIVELY forces immediate-promotion, making e.g. constexpr operator= for vec consteval,
		// and breaking runtime code.

		if not consteval {
			spdlog::trace(fmt::vformat(fmt_string, fmt::make_format_args(args...)));
		}
	}
};

#ifndef NDEBUG
#define LOG_SPECIAL_MEMBER_FUNCS_DEBUG(...) : flag_special_member_funcs < __VA_ARGS__ >
#else
#define LOG_SPECIAL_MEMBER_FUNCS_DEBUG(...)
#endif

// Conditionally inheriting from flag_special_member_funcs makes types non-trivially constructible,
// so a move becomes appropriate.
#ifndef NDEBUG
#define MOVE_IF_DEBUG(a) std::move(a)
#else
#define MOVE_IF_DEBUG(a) a
#endif
