/*
 * Particle.h
 *
 *  Created on: 23.02.2010
 *      Author: eckhardw
 */

#pragma once

#include <array>
#include <iostream>
#include <source_location>
#include <string>
#include <type_traits>

#include "Vector.h"

/**
 * @brief Represents a single particle with position, velocity, force, and mass.
 */
class Particle {
private:
	/**
	 * Position of the particle
	 */
	vec x;

	/**
	 * Velocity of the particle
	 */
	vec v;

	/**
	 * Force effective on this particle
	 */
	vec f{};

	/**
	 * Force which was effective on this particle
	 */
	vec old_f{};

	/**
	 * Mass of this particle
	 */
	double m;

	/**
	 * Type of the particle. Use it for whatever you want (e.g. to separate
	 * molecules belonging to different bodies, matters, and so on)
	 */
	int type;

	/**
	 * @brief Prints a log message only at runtime.
	 *
	 * This method ensures that logging statements are skipped
	 * during compile-time evaluation (constexpr contexts).
	 *
	 * @param msg The message to print.
	 */
	constexpr void runtime_log(std::string_view msg) {
		if (!std::is_constant_evaluated()) {
			std::cout << msg;
		}
	}

	/**
	 * @brief Logs the creation of a particle through a special member function.
	 *
	 * @param by A description of how the particle was created (e.g., "copy", "move").
	 * @param location Automatically captured source location of the call.
	 */
	constexpr void log_special_mem(std::string_view by, const std::source_location& location) {
		runtime_log(
			std::format(
				"{}:{}:{}: Particle generated by {}!\n", location.file_name(), location.line(), location.column(), by
			)
		);
	}

public:
	/**
	 * @brief Default constructor.
	 *
	 * Creates a particle of the given type with zero-initialized attributes.
	 *
	 * @param type_arg The particle type identifier (defaults to 0).
	 * @param loc Captured source location for logging (do not set manually).
	 */
	constexpr explicit Particle(
		int type_arg = 0, const std::source_location& loc = std::source_location::current()
	) noexcept
		: x(0, 0, 0)
		, v(0, 0, 0)
		, m(0.)
		, type(type_arg) {
		log_special_mem("default construction", loc);
	}

	/**
	 * @brief Copy constructor.
	 *
	 * Creates a new particle by copying all attributes from another.
	 *
	 * @param other The particle to copy.
	 * @param loc Captured source location for logging (do not set manually).
	 */
	constexpr Particle(
		const Particle& other, const std::source_location& loc = std::source_location::current()
	) noexcept
		: x(other.x)
		, v(other.v)
		, f(other.f)
		, old_f(other.old_f)
		, m(other.m)
		, type(other.type) {
		log_special_mem("copy", loc);
	}

	/**
	 * @brief Move constructor.
	 *
	 * Transfers ownership of the contents of another particle.
	 *
	 * Computationally equivalent to a copy, exists only to distinguish between
	 * implicit moves and implicit copies via runtime logging.
	 *
	 * @param other The particle to move from.
	 * @param loc Captured source location for logging (do not set manually).
	 */
	constexpr Particle(Particle&& other, const std::source_location& loc = std::source_location::current()) noexcept
		: x(std::move(other.x))
		, v(std::move(other.v))
		, f(std::move(other.f))
		, old_f(std::move(other.old_f))
		, m(other.m)
		, type(other.type) {
		log_special_mem("move", loc);
	}

	/**
	 * @brief Copy assignment operator.
	 *
	 * Copies all attributes from another particle.
	 * @param other The particle to copy from.
	 * @return Reference to this particle.
	 */
	constexpr Particle& operator=(const Particle& other) noexcept {
		x = other.x;
		v = other.v;
		f = other.f;
		old_f = other.old_f;
		m = other.m;
		type = other.type;
		runtime_log("Particle generated by copy assignment!\n");
		return *this;
	}

	/**
	 * @brief Move assignment operator.
	 *
	 * Transfers ownership of the contents of another particle.
	 *
	 * Computationally equivalent to a copy assignment, exists only to
	 * distinguish between implicit move and implicit copies via runtime
	 * logging.
	 *
	 * @param other The particle to move from.
	 * @return Reference to this particle.
	 */
	constexpr Particle& operator=(Particle&& other) noexcept {
		x = std::move(other.x);
		v = std::move(other.v);
		f = std::move(other.f);
		old_f = std::move(other.old_f);
		m = other.m;
		type = other.type;
		runtime_log("Particle generated by move assignment!\n");
		return *this;
	}

	/**
	 * @brief Parameterized constructor.
	 *
	 * Initializes a particle with the given position, velocity, mass, and type.
	 *
	 * @param x_arg Initial position.
	 * @param v_arg Initial velocity.
	 * @param m_arg Mass of particle.
	 * @param type_arg Type identifier of particle (defaults to 0).
	 * @param loc Captured source location for logging (do not set manually).
	 */
	constexpr Particle(
		// for visualization, we need always 3 coordinates
	    // -> in case of 2d, we use only the first and the second
		vec x_arg, vec v_arg, double m_arg, int type_arg = 0,
		const std::source_location& loc = std::source_location::current()
	) noexcept
		: x(std::move(x_arg))
		, v(std::move(v_arg))
		, m(m_arg)
		, type(type_arg)

	{
		log_special_mem("parameterized construction", loc);
	}

	/**
	 * @brief Destructor.
	 *
	 * Logs the particle’s destruction (only at runtime).
	 * Trivial otherwise.
	 */
	constexpr virtual ~Particle() noexcept {
		runtime_log("Particle destructed!\n");
	}

	/** @brief Returns the current position of this particle. */
	constexpr const vec& getX() const {
		return x;
	}

	/** @brief Sets the position of this particle. */
	constexpr void setX(const vec new_x) noexcept {
		x = new_x;
	}

	/** @brief Returns the current velocity of this particle. */
	constexpr const vec& getV() const {
		return v;
	}

	/** @brief Sets the velocity of this particle. */
	constexpr void setV(const vec& new_v) noexcept {
		v = new_v;
	}

	/** @brief Returns the current force acting on the particle. */
	constexpr const vec& getF() const {
		return f;
	}

	/** @brief Sets the current force acting on the particle. */
	constexpr void setF(const vec& new_f) noexcept {
		f = new_f;
	}

	/** @brief Returns the previous force acting on the particle. */
	constexpr const vec& getOldF() const {
		return old_f;
	}

	/** @brief Sets the previous force acting on the particle. */
	constexpr void setOldF(const vec& new_old_f) noexcept {
		old_f = new_old_f;
	}

	/** @brief Returns the mass of this particle. */
	constexpr double getM() const {
		return m;
	}

	/** @brief Returns this particle’s type identifier. */
	constexpr int getType() const {
		return type;
	}

	/**
	 * @brief Compares two particles for equality.
	 * @param other The particle to compare with.
	 * @return `true` @a iff all properties match.
	 */
	constexpr bool operator==(const Particle& other) const = default;

	// Reimplemented from the given implementation because:
	// https://quick-bench.com/q/qDcxmk_OjShhSwf_VKAQ_6abBwE
	/**
	 * @brief Converts this particle to a human-readable string.
	 *
	 * @return A string with the content
	 * @verbatim Particle X: <x> v: <v> f: <f> old_f: <f> type: <type> @endverbatim
	 */
	std::string toString() const {
		// TODO(tuna): if this method is just a hoop for operator<< and is not used anywhere else,
		// it will probably be more performant to avoid the temporary `result` string.
		std::string result;
		std::format_to(
			std::back_inserter(result), "Particle X: {} v: {} f: {} old_f: {} type: {}", x, v, f, old_f, type
		);
		return result;
	}
};

/**
 * @brief Stream output operator for Particle.
 *
 * Allows output of particles using `operator<<`.
 *
 * @param stream Output stream to print into.
 * @param p Particle to print.
 * @return Reference to the modified output stream.
 */
constexpr std::ostream& operator<<(std::ostream& stream, Particle& p) {
	stream << p.toString();
	return stream;
}
