#pragma once

#include "utility/fixed_string.hpp"
#include "utility/tracing/macros.hpp"

/**
 * @brief Class to log special member function calls of deriving classes.
 *
 * @tparam DerivedName A compile-time fixed string representing the name of the derived type.
 */
template <p3094::fixed_string DerivedName>
class trace_special_memfuns {
public:
	/// Constructor, logs deriving object construction.
	// NOLINTNEXTLINE(*explicit*)
	constexpr trace_special_memfuns() {
		log_construction("generic construction");
	}

	/// Copy constructor, logs deriving object being copied.
	constexpr trace_special_memfuns(const trace_special_memfuns&) noexcept {
		log_construction("copy");
	}

	/// Move constructor, logs deriving object being moved.
	constexpr trace_special_memfuns(trace_special_memfuns&&) noexcept {
		log_construction("move");
	}

	/**
	 * @brief Copy assignment operator, logs deriving object being copied.
	 * @return Reference to *this.
	 */
	// NOLINTNEXTLINE(cert-oop54-cpp)
	constexpr trace_special_memfuns& operator=(const trace_special_memfuns&) noexcept {
		static constexpr auto log_line = DerivedName + " copy assigned!\n";
		runtime_log(log_line.view());
		return *this;
	}

	/**
	 * @brief Move assignment operator, logs deriving object being moved.
	 * @return Reference to *this.
	 */
	constexpr trace_special_memfuns& operator=(trace_special_memfuns&&) noexcept {
		static constexpr auto log_line = DerivedName + " move assigned!\n";
		runtime_log(log_line.view());
		return *this;
	}

	/// Destructor, logs deriving object being destroyed.
	constexpr ~trace_special_memfuns() noexcept {
		static constexpr auto log_line = DerivedName + " destructed!\n";
		runtime_log(log_line.view());
	}

	/**
	 * @brief Equality comparison.
	 * Will always return true as class has no members. Defined so that deriving classes can have
	 * operator== and not error out when this base class is not equality comparable.
	 * @return `true`.
	 */
	constexpr bool operator==(const trace_special_memfuns&) const = default;

	/**
	 * @brief Logs the creation of a deriving object through a construction.
	 *
	 * @param by A description of which base class constructor was invoked for the construction of
	 * the deriving object (e.g., "copy", "move").
	 */
	static constexpr void log_construction(std::string_view by) {
		static constexpr auto log_line = DerivedName + " generated by {}\n";
		runtime_log(log_line.view(), by);
	}

	/**
	 * @brief Logs the reason for the creation of a deriving object.
	 *
	 * Meant to be called from the deriving constructor's body, where more information than just the
	 * default construction of a trace object is available.
	 *
	 * @param reason A description of why the deriving object was created
	 */
	static constexpr void annotate_construction(std::string_view reason) {
		static constexpr auto log_line = DerivedName + "'s last logged construction was {}\n";
		runtime_log(log_line.view(), reason);
	}

	/**
	 * @brief Prints a log message only at runtime.
	 *
	 * This method ensures that logging statements are skipped
	 * during compile-time evaluation (constexpr contexts).
	 *
	 * @tparam Args Variadic pack of argument types passed to the formatting facility.
	 * @param fmt_string String describing the format of the output.
	 * @param args Arguments to format according to `fmt_string`.
	 */
	template <typename... Args>
	static constexpr void runtime_log(
		[[maybe_unused]] fmt::format_string<Args...> fmt_string, [[maybe_unused]] Args&&... args
	) {
		TRACE_SPECIAL_MEMFUNS(fmt_string, std::forward<Args>(args)...);
	}
};

// TODO(tuna): without this guard GCC cannot destruct arrays of Particles at constexpr time,
// which I suspect is a bug, but I'll look into it (clang manages fine)
#if !defined(IS_GCC) && LOG_SPECIAL_MEMFUNS
/// Log calls into the special member functions of deriving objects, tagged with specified name.
#define TRACE_SPECIAL_MEMFUNS_FOR_CLASS(...) : trace_special_memfuns < __VA_ARGS__ >
#else
#define TRACE_SPECIAL_MEMFUNS_FOR_CLASS(...)
#endif

// Conditionally inheriting from trace_special_memfuns makes types non-trivially constructible,
// so a move becomes appropriate.
#if LOG_SPECIAL_MEMFUNS
/// `std::move` if in debug, do nothing otherwise.
#define MOVE_IF_DEBUG(a) std::move(a)
#else
#define MOVE_IF_DEBUG(a) a
#endif
