/**
 * @file gtest_constexpr.h
 * @brief Provides constexpr-capable GoogleTest-style assertions.
 *
 * For almost every GoogleTest assertion of the form `ASSERT_*` / `EXPECT_*`, this header
 * provides a `STATIC_ASSERT*` / `STATIC_EXPECT*` equivalent, which has the same
 * semantic as the underlying GoogleTest macro, but evaluates at compile time using
 * `static_assert`.
 *
 * Exception assertions are not supported because `constexpr` exceptions are
 * a C++26 feature [P3068].
 *
 * Formatting predicate assertions are not supported because user generated
 * `static_assert` messages are a C++26 feature [P2741].
 *
 * Windows HRESULT Assertions are not supported because interacting with
 * the operating system is impossible at compile time.
 *
 * Death assertions are not supported because "verify[ing] that a piece of code
 * causes the program to terminate" is impossible at compile time.
 *
 * `STATIC_*` checks compiling is them passing. The only runtime
 * code generated from these calls is a `SUCCEED()` statement to integrate
 * cleanly back into the normal GoogleTest workflow.
 *
 * When `GTEST_CONFIG_RUNTIME_STATIC_EXPECT` is defined, these macros fall back
 * to regular GoogleTest runtime checks.
 *
 * There exists no difference between `STATIC_ASSERT_*` and `STATIC_EXPECT_*`
 * variants at compile time, but they will correctly fall back to the corresponding
 * runtime assertion if `GTEST_CONFIG_RUNTIME_STATIC_EXPECT` is set.
 *
 * @see This serves as a GoogleTest parallel to Catch2's
 * <a href="https://catch2-temp.readthedocs.io/en/latest/other-macros.html">`STATIC_REQUIRE`
 * and `CATCH_CONFIG_RUNTIME_STATIC_REQUIRE`</a>.
 */
#pragma once

#include "internal/stamps.h"

// The Doxygen documentation within this file is mostly generated by aliases.
// Use the resulting Doxygen output instead of reading this file.

// Documentation copied over from GoogleTest whenever relevant:
// https://google.github.io/googletest/reference/assertions.html

/**
 * @gtest_sect{TRUE,condition}
 *
 * @brief Verifies that @p condition is `true`.
 * @param condition A boolean expression.
 */

/** @gtest_equ{ASSERT_TRUE,condition} */
#define STATIC_ASSERT_TRUE(condition) GTEST_CONSTEXPR_INTERNAL_STAMP_TRUE(ASSERT, condition)

/** @gtest_equ{EXPECT_TRUE,condition} */
#define STATIC_EXPECT_TRUE(condition) GTEST_CONSTEXPR_INTERNAL_STAMP_TRUE(EXPECT, condition)
/// @}

/**
 * @gtest_sect{FALSE,condition}
 *
 * @brief Verifies that @p condition is `false`.
 * @param condition A boolean expression.
 */

/** @gtest_equ{ASSERT_FALSE,condition} */
#define STATIC_ASSERT_FALSE(condition) GTEST_CONSTEXPR_INTERNAL_STAMP_FALSE(ASSERT, condition)

/** @gtest_equ{EXPECT_FALSE,condition} */
#define STATIC_EXPECT_FALSE(condition) GTEST_CONSTEXPR_INTERNAL_STAMP_FALSE(EXPECT, condition)
/// @}

/**
 * @gtest_cmp_section_header{EQ,==}
 *
 * Does pointer equality on pointers.
 *
 * By default, this does not have strictly the same functionality as its GTest counterpart,
 * as it does not call into Google's `EqHelper::Compare` but uses `operator==` directly.
 * This is done to improve failure messages, as calling into an overload set does not
 * result in a direct "expression evaluates to '1 == 2'" message from the compiler but
 * a plain comparison does.
 *
 * The only instance where this changes the behavior of this function is with
 * GCC 4 and anonymous enums.
 *
 * Set `GTEST_CONFIG_EQ_NO_SHORTCUT` to force Google's implementation.
 *
 * @gtest_params_val
 */

/** @gtest_equ_val{ASSERT_EQ} */
#define STATIC_ASSERT_EQ(val1, val2) GTEST_CONSTEXPR_INTERNAL_STAMP_EQ(ASSERT, val1, val2)

/** @gtest_equ_val{EXPECT_EQ} */
#define STATIC_EXPECT_EQ(val1, val2) GTEST_CONSTEXPR_INTERNAL_STAMP_EQ(EXPECT, val1, val2)
/// @}

/** @gtest_cmp_section_begin{NE,!=} */

/** @gtest_equ_val{ASSERT_NE} */
#define STATIC_ASSERT_NE(val1, val2) GTEST_CONSTEXPR_INTERNAL_STAMP_NE(ASSERT, val1, val2)

/** @gtest_equ_val{EXPECT_NE} */
#define STATIC_EXPECT_NE(val1, val2) GTEST_CONSTEXPR_INTERNAL_STAMP_NE(EXPECT, val1, val2)
/// @}

/** @gtest_cmp_section_begin{LE,<=} */

/** @gtest_equ_val{ASSERT_LE} */
#define STATIC_ASSERT_LE(val1, val2) GTEST_CONSTEXPR_INTERNAL_STAMP_LE(ASSERT, val1, val2)

/** @gtest_equ_val{EXPECT_LE} */
#define STATIC_EXPECT_LE(val1, val2) GTEST_CONSTEXPR_INTERNAL_STAMP_LE(EXPECT, val1, val2)
/// @}

/** @gtest_cmp_section_begin{LT,<} */

/** @gtest_equ_val{ASSERT_LT} */
#define STATIC_ASSERT_LT(val1, val2) GTEST_CONSTEXPR_INTERNAL_STAMP_LT(ASSERT, val1, val2)

/** @gtest_equ_val{EXPECT_LT} */
#define STATIC_EXPECT_LT(val1, val2) GTEST_CONSTEXPR_INTERNAL_STAMP_LT(EXPECT, val1, val2)
/// @}

/** @gtest_cmp_section_begin{GE,>=} */

/** @gtest_equ_val{ASSERT_GE} */
#define STATIC_ASSERT_GE(val1, val2) GTEST_CONSTEXPR_INTERNAL_STAMP_GE(ASSERT, val1, val2)

/** @gtest_equ_val{EXPECT_GE} */
#define STATIC_EXPECT_GE(val1, val2) GTEST_CONSTEXPR_INTERNAL_STAMP_GE(EXPECT, val1, val2)
/// @}

/** @gtest_cmp_section_begin{GT,>} */

/** @gtest_equ_val{ASSERT_GT} */
#define STATIC_ASSERT_GT(val1, val2) GTEST_CONSTEXPR_INTERNAL_STAMP_GT(ASSERT, val1, val2)

/** @gtest_equ_val{EXPECT_GT} */
#define STATIC_EXPECT_GT(val1, val2) GTEST_CONSTEXPR_INTERNAL_STAMP_GT(EXPECT, val1, val2)
/// @}

/**
 * @gtest_str_section_header{STREQ,the same}
 *
 * These assertions compare two C strings. To compare two `std::string` objects,
 * use EXPECT_EQ or EXPECT_NE instead.
 *
 * @gtest_params_str
 */

/** @gtest_equ_str{ASSERT_STREQ} */
#define STATIC_ASSERT_STREQ(str1, str2) GTEST_CONSTEXPR_INTERNAL_STAMP_STREQ(ASSERT, str1, str2)

/** @gtest_equ_str{EXPECT_STREQ} */
#define STATIC_EXPECT_STREQ(str1, str2) GTEST_CONSTEXPR_INTERNAL_STAMP_STREQ(EXPECT, str1, str2)
/// @}

/** @gtest_str_section_begin{STRNE,different} */

/** @gtest_equ_str{ASSERT_STRNE} */
#define STATIC_ASSERT_STRNE(str1, str2) GTEST_CONSTEXPR_INTERNAL_STAMP_STRNE(ASSERT, str1, str2)

/** @gtest_equ_str{EXPECT_STRNE} */
#define STATIC_EXPECT_STRNE(str1, str2) GTEST_CONSTEXPR_INTERNAL_STAMP_STRNE(EXPECT, str1, str2)
/// @}

/** @gtest_str_ins_section_begin{STRCASEEQ,the same}  */

/** @gtest_equ_str{ASSERT_STRCASEEQ} */
#define STATIC_ASSERT_STRCASEEQ(str1, str2) GTEST_CONSTEXPR_INTERNAL_STAMP_STRCASEEQ(ASSERT, str1, str2)

/** @gtest_equ_str{EXPECT_STRCASEEQ} */
#define STATIC_EXPECT_STRCASEEQ(str1, str2) GTEST_CONSTEXPR_INTERNAL_STAMP_STRCASEEQ(EXPECT, str1, str2)
/// @}

/** @gtest_str_ins_section_begin{STRCASENE,different}  */

/** @gtest_equ_str{ASSERT_STRCASENE} */
#define STATIC_ASSERT_STRCASENE(str1, str2) GTEST_CONSTEXPR_INTERNAL_STAMP_STRCASENE(ASSERT, str1, str2)

/** @gtest_equ_str{EXPECT_STRCASENE} */
#define STATIC_EXPECT_STRCASENE(str1, str2) GTEST_CONSTEXPR_INTERNAL_STAMP_STRCASENE(EXPECT, str1, str2)
/// @}

/**
 * @gtest_fp_section_header{FLOAT_EQ,float}
 *
 * Checks if valus are within 4 ULPs from each other. Infinity and the largest finite float
 * value are considered to be one ULP apart.
 * @see To learn more about ULPs,
 * <a href="https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/">
 * see this blog</a>.
 *
 * @gtest_params_val
 */

/** @gtest_equ_val{ASSERT_FLOAT_EQ} */
#define STATIC_ASSERT_FLOAT_EQ(val1, val2) GTEST_CONSTEXPR_INTERNAL_STAMP_FLOAT_EQ(ASSERT, val1, val2)

/** @gtest_equ_val{EXPECT_FLOAT_EQ} */
#define STATIC_EXPECT_FLOAT_EQ(val1, val2) GTEST_CONSTEXPR_INTERNAL_STAMP_FLOAT_EQ(EXPECT, val1, val2)
/// @}

/** @gtest_fp_section_begin{DOUBLE_EQ,double} */

/** @gtest_equ_val{ASSERT_DOUBLE_EQ} */
#define STATIC_ASSERT_DOUBLE_EQ(val1, val2) GTEST_CONSTEXPR_INTERNAL_STAMP_DOUBLE_EQ(ASSERT, val1, val2)

/** @gtest_equ_val{EXPECT_DOUBLE_EQ} */
#define STATIC_EXPECT_DOUBLE_EQ(val1, val2) GTEST_CONSTEXPR_INTERNAL_STAMP_DOUBLE_EQ(EXPECT, val1, val2)
/// @}

/** @gtest_sect{NEAR,val1,val2,abs_error}
 *
 * @brief Verifies that the difference between `val1` and `val2` does not
 * exceed the absolute error bound abs_error.
 *
 * If val and val2 are both infinity of the same sign, the difference is considered to be 0.
 * Otherwise, if either value is infinity, the difference is considered to be infinity. All
 * non-NaN values (including infinity) are considered to not exceed an `abs_error` of infinity.
 *
 * @gtest_params_val
 * @param abs_error The maximum allowed absolute difference between `val1` and `val2`
 * for them to be considered approximately equal. Must be a non-negative
 * floating-point value.
 */

/** @gtest_equ{ASSERT_NEAR,val1,val2,abs_error} */
#define STATIC_ASSERT_NEAR(val1, val2, abs_error) GTEST_CONSTEXPR_INTERNAL_STAMP_NEAR(ASSERT, val1, val2, abs_error)

/** @gtest_equ{EXPECT_NEAR,val1,val2,abs_error} */
#define STATIC_EXPECT_NEAR(val1, val2, abs_error) GTEST_CONSTEXPR_INTERNAL_STAMP_NEAR(EXPECT, val1, val2, abs_error)
/// @}

/** @name STATIC_{ASSERT,EXPECT}_PRED*(val1[, val2, val3, val4, val5])
 * @{
 * @brief Verifies that the predicate `pred` returns `true` when passed the given values as
 * arguments.
 *
 * @param pred Function or functor that accepts as many arguments as the corresponding macro
 * accepts values.
 * @param val1 First argument to pass into `pred`.
 * @gtest_nth_param{2,Second}
 * @gtest_nth_param{3,Third}
 * @gtest_nth_param{4,Fourth}
 * @param val5 Fifth argument to pass into `pred` (for `*PRED5`).
 */

/** @gtest_equ{ASSERT_PRED1,pred,val1} */
#define STATIC_ASSERT_PRED1(pred, val1) GTEST_CONSTEXPR_INTERNAL_STAMP_PRED1(ASSERT, pred, val1)

/** @gtest_equ{EXPECT_PRED1,pred,val1} */
#define STATIC_EXPECT_PRED1(pred, val1) GTEST_CONSTEXPR_INTERNAL_STAMP_PRED1(EXPECT, pred, val1)

/** @gtest_equ{ASSERT_PRED2,pred,val1,val2} */
#define STATIC_ASSERT_PRED2(pred, val1, val2) GTEST_CONSTEXPR_INTERNAL_STAMP_PRED2(ASSERT, pred, val1, val2)

/** @gtest_equ{EXPECT_PRED2,pred,val1,val2} */
#define STATIC_EXPECT_PRED2(pred, val1, val2) GTEST_CONSTEXPR_INTERNAL_STAMP_PRED2(EXPECT, pred, val1, val2)

/** @gtest_equ{ASSERT_PRED3,pred,val1,val2,val3} */
#define STATIC_ASSERT_PRED3(pred, val1, val2, val3) GTEST_CONSTEXPR_INTERNAL_STAMP_PRED3(ASSERT, pred, val1, val2, val3)

/** @gtest_equ{EXPECT_PRED3,pred,val1,val2,val3} */
#define STATIC_EXPECT_PRED3(pred, val1, val2, val3) GTEST_CONSTEXPR_INTERNAL_STAMP_PRED3(EXPECT, pred, val1, val2, val3)

/** @gtest_equ{ASSERT_PRED4,pred,val1,val2,val3,val4} */
#define STATIC_ASSERT_PRED4(pred, val1, val2, val3, val4)                                                              \
	GTEST_CONSTEXPR_INTERNAL_STAMP_PRED4(ASSERT, pred, val1, val2, val3, val4)

/** @gtest_equ{EXPECT_PRED4,pred,val1,val2,val3,val4} */
#define STATIC_EXPECT_PRED4(pred, val1, val2, val3, val4)                                                              \
	GTEST_CONSTEXPR_INTERNAL_STAMP_PRED4(EXPECT, pred, val1, val2, val3, val4)

/** @gtest_equ{ASSERT_PRED5,pred,val1,val2,val3,val4,val5} */
#define STATIC_ASSERT_PRED5(pred, val1, val2, val3, val4, val5)                                                        \
	GTEST_CONSTEXPR_INTERNAL_STAMP_PRED5(ASSERT, pred, val1, val2, val3, val4, val5)

/** @gtest_equ{EXPECT_PRED5,pred,val1,val2,val3,val4,val5} */
#define STATIC_EXPECT_PRED5(pred, val1, val2, val3, val4, val5)                                                        \
	GTEST_CONSTEXPR_INTERNAL_STAMP_PRED5(EXPECT, pred, val1, val2, val3, val4, val5)
/// @}


// TODO(anyone): document me
#include "CompilerTraits.h"

#ifdef IS_GCC
#define GCC_STATIC_ASSERT_EQ(a, b) STATIC_ASSERT_EQ(a, b)
#define GCC_STATIC_EXPECT_EQ(a, b) STATIC_EXPECT_EQ(a, b)

#define GCC_STATIC_ASSERT_TRUE(condition) STATIC_ASSERT_TRUE(condition)
#define GCC_STATIC_EXPECT_TRUE(condition) STATIC_EXPECT_TRUE(condition)

#define GCC_STATIC_ASSERT_DOUBLE_EQ(a, b) STATIC_ASSERT_DOUBLE_EQ(a, b)
#define GCC_STATIC_EXPECT_DOUBLE_EQ(a, b) STATIC_EXPECT_DOUBLE_EQ(a, b)

#define GCC_STATIC_ASSERT_NEAR(a, b, abs_error) STATIC_ASSERT_NEAR(a, b, abs_error)
#define GCC_STATIC_EXPECT_NEAR(a, b, abs_error) STATIC_EXPECT_NEAR(a, b, abs_error)

#else

#define GCC_STATIC_ASSERT_EQ(a, b) ASSERT_EQ(a, b)
#define GCC_STATIC_EXPECT_EQ(a, b) EXPECT_EQ(a, b)

#define GCC_STATIC_ASSERT_TRUE(condition) ASSERT_TRUE(condition)
#define GCC_STATIC_EXPECT_TRUE(condition) EXPECT_TRUE(condition)

#define GCC_STATIC_ASSERT_DOUBLE_EQ(a, b) ASSERT_DOUBLE_EQ(a, b)
#define GCC_STATIC_EXPECT_DOUBLE_EQ(a, b) EXPECT_DOUBLE_EQ(a, b)

#define GCC_STATIC_ASSERT_NEAR(a, b, abs_error) ASSERT_NEAR(a, b, abs_error)
#define GCC_STATIC_EXPECT_NEAR(a, b, abs_error) EXPECT_NEAR(a, b, abs_error)
#endif

#ifndef GTEST_CONFIG_RUNTIME_STATIC_EXPECT
#define GTEST_CXP constexpr
#else
#define GTEST_CXP
#endif

#ifdef IS_GCC
#define GTEST_CXP_GCC GTEST_CXP
#else
#define GTEST_CXP_GCC
#endif
